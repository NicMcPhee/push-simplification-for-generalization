

@Article{Helmuth:2015:ieeeTEC,
	author =	"Thomas Helmuth and Lee Spector and James Matheson",
	title =	"Solving Uncompromising Problems with Lexicase
	Selection",
	journal =	"IEEE Transactions on Evolutionary Computation",
	year = 	"2015",
	volume =	"19",
	number =	"5",
	pages =	"630--643",
	month =	oct,
	keywords =	"genetic algorithms, genetic programming, parent
	selection, lexicase selection, tournament selection,
	PushGP",
	ISSN = 	"1089-778X",
	URL =  	"http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6920034",
	doi =  	"doi:10.1109/TEVC.2014.2362729",
	size = 	"14 pages",
	abstract =	"We describe a broad class of problems, called
	uncompromising problems, characterised by the
	requirement that solutions must perform optimally on
	each of many test cases. Many of the problems that have
	long motivated genetic programming research, including
	the automation of many traditional programming tasks,
	are uncompromising. We describe and analyse the
	recently proposed lexicase parent selection algorition
	and show that it can facilitate the solution of
	uncompromising problems by genetic programming. Unlike
	most traditional parent selection techniques, lexicase
	selection does not base selection on a fitness value
	that is aggregated over all test cases; rather, it
	considers test cases one at a time in random order. We
	present results comparing lexicase selection to more
	traditional parent selection methods, including
	standard tournament selection and implicit fitness
	sharing, on four uncompromising problems: finding terms
	in finite algebras, designing digital multipliers,
	counting words in files, and performing symbolic
	regression of the factorial function. We provide
	evidence that lexicase selection maintains higher
	levels of population diversity than other selection
	methods, which may partially explain its utility as a
	parent selection algorithm in the context of
	uncompromising problems.",
	notes =	"also known as \cite{6920034}",
	doi-url =	"http://dx.doi.org/10.1109/TEVC.2014.2362729",
}

@phdthesis{Helmuth:2015:dissertation,
	author = {Thomas Helmuth},
	title = {General Program Synthesis from Examples Using Genetic Programming with Parent Selection Based on Random Lexicographic Orderings of Test Cases},
	type = {{Ph.D.} dissertation},
	institution = {University of Massachusetts, Amherst},
	date = {September, 2015},
	year = {2015},
	url = {http://scholarworks.umass.edu/dissertations_2/465/},
}

@InProceedings{Helmuth:2015:GECCO,
  author =	"Thomas Helmuth and Lee Spector",
  title =	"General Program Synthesis Benchmark Suite",
  booktitle =	"GECCO '15: Proceedings of the 2015 on Genetic and
		 Evolutionary Computation Conference",
  year = 	"2015",
  NOeditor =	"Sara Silva and Anna I Esparcia-Alcazar and Manuel
		 Lopez-Ibanez and Sanaz Mostaghim and Jon Timmis and
		 Christine Zarges and Luis Correia and Terence Soule and
		 Mario Giacobini and Ryan Urbanowicz and Youhei Akimoto
		 and Tobias Glasmachers and Francisco {Fernandez de
		 Vega} and Amy Hoover and Pedro Larranaga and Marta Soto
		 and Carlos Cotta and Francisco B. Pereira and Julia
		 Handl and Jan Koutnik and Antonio Gaspar-Cunha and
		 Heike Trautmann and Jean-Baptiste Mouret and Sebastian
		 Risi and Ernesto Costa and Oliver Schuetze and
		 Krzysztof Krawiec and Alberto Moraglio and Julian F.
		 Miller and Pawel Widera and Stefano Cagnoni and JJ
		 Merelo and Emma Hart and Leonardo Trujillo and Marouane
		 Kessentini and Gabriela Ochoa and Francisco Chicano and
		 Carola Doerr",
  isbn13 =	"978-1-4503-3472-3",
  pages =	"1039--1046",
  keywords =	"genetic algorithms, genetic programming",
  month =	"11-15 " # jul,
  organisation = "SIGEVO",
  address =	"Madrid, Spain",
  URL =  	"http://doi.acm.org/10.1145/2739480.2754769",
  doi =  	"doi:10.1145/2739480.2754769",
  publisher =	"ACM",
  publisher_address = "New York, NY, USA",
  abstract =	"Recent interest in the development and use of
		 non-trivial benchmark problems for genetic programming
		 research has highlighted the scarcity of general
		 program synthesis (also called traditional programming)
		 benchmark problems. We present a suite of 29 general
		 program synthesis benchmark problems systematically
		 selected from sources of introductory computer science
		 programming problems. This suite is suitable for
		 experiments with any program synthesis system driven by
		 input/output examples. We present results from
		 illustrative experiments using our reference
		 implementation of the problems in the PushGP genetic
		 programming system. The results show that the problems
		 in the suite vary in difficulty and can be useful for
		 assessing the capabilities of a program synthesis
		 system.",
  notes =	"Also known as \cite{2754769} GECCO-2015 A joint
		 meeting of the twenty fourth international conference
		 on genetic algorithms (ICGA-2015) and the twentith
		 annual genetic programming conference (GP-2015)",
  doi-url =	"http://dx.doi.org/10.1145/2739480.2754769",
}

@InProceedings{Helmuth:2013:GECCOcomp,
	author =	"Thomas Helmuth and Lee Spector",
	title =	"Evolving a digital multiplier with the pushgp genetic
	programming system",
	booktitle =	"GECCO '13 Companion: Proceeding of the fifteenth
	annual conference companion on Genetic and evolutionary
	computation conference companion",
	year = 	"2013",
	TooManyeditor =	"Christian Blum and Enrique Alba and Thomas
	Bartz-Beielstein and Daniele Loiacono and Francisco
	Luna and Joern Mehnen and Gabriela Ochoa and Mike
	Preuss and Emilia Tantar and Leonardo Vanneschi",
	isbn13 =	"978-1-4503-1964-5",
	keywords =	"genetic algorithms, genetic programming",
	pages =	"1627--1634",
	month =	"6-10 " # jul,
	organisation = "SIGEVO",
	address =	"Amsterdam, The Netherlands",
	doi =  	"doi:10.1145/2464576.2466814",
	publisher =	"ACM",
	publisher_address = "New York, NY, USA",
	abstract =	"A recent article on benchmark problems for genetic
	programming suggested that researchers focus attention
	on the digital multiplier problem, also known as the
	multiple output multiplier problem, in part because it
	is scalable and in part because the requirement of
	multiple outputs presents challenges for some forms of
	genetic programming [20]. Here we demonstrate the
	application of stack-based genetic programming to the
	digital multiplier problem using the PushGP genetic
	programming system, which evolves programs expressed in
	the stack-based Push programming language. We
	demonstrate the use of output instructions and argue
	that they provide a natural mechanism for producing
	multiple outputs in a stack-based genetic programming
	context. We also show how two recent developments in
	PushGP dramatically improve the performance of the
	system on the digital multiplier problem. These
	developments are the ULTRA genetic operator, which
	produces offspring via Uniform Linear Transformation
	with Repair and Alternation [12], and lexicase
	selection, which selects parents according to
	performance on cases considered sequentially in random
	order [11]. Our results using these techniques show not
	only their utility, but also the utility of the digital
	multiplier problem as a benchmark problem for genetic
	programming research. The results also demonstrate the
	exibility of stack-based genetic programming for
	solving problems with multiple outputs and for serving
	as a platform for experimentation with new genetic
	programming techniques.",
	notes =	"Also known as \cite{2466814} Distributed at
	GECCO-2013.",
	doi-url =	"http://dx.doi.org/10.1145/2464576.2466814",
}

@InCollection{Spector:2013:GPTP,
	author =	"Lee Spector and Thomas Helmuth",
	title =	"Uniform Linear Transformation with Repair and
	Alternation in Genetic Programming",
	booktitle =	"Genetic Programming Theory and Practice XI",
	year = 	"2013",
	series =	"Genetic and Evolutionary Computation",
	NOeditor =	"Rick Riolo and Jason H. Moore and Mark Kotanchek",
	publisher =	"Springer",
	chapter =	"8",
	pages =	"137--153",
	address =	"Ann Arbor, USA",
	month =	"9-11 " # may,
	keywords =	"genetic algorithms, genetic programming, Uniform
	mutation, Uniform crossover, ULTRA, Push, PushGP, Drug
	bioavailability problem, Pagie-1 problem, Factorial
	regression, Boolean multiplexer problem",
	isbn13 =	"978-1-4939-0374-0",
	doi =  	"doi:10.1007/978-1-4939-0375-7_8",
	abstract =	"Several genetic programming researchers have argued
	for the utility of genetic operators that act
	uniformly. By act uniformly we mean two specific
	things: that the probability of an inherited program
	component being modified during inheritance is
	independent of the size and shape of the parent
	programs beyond the component in question; and that
	pairs of parents are combined in ways that allow
	arbitrary combinations of components from each parent
	to appear in the child. Uniform operators described in
	previous work have had limited utility, however,
	because of a mismatch between the relevant notions of
	uniformity and the hierarchical structure and variable
	sizes of many genetic programming representations. In
	this chapter we describe a new genetic operator, ULTRA,
	which incorporates aspects of both mutation and
	crossover and acts approximately uniformly across
	programs of variable sizes and structures. ULTRA treats
	hierarchical programs as linear sequences and includes
	a repair step to ensure that syntax constraints are
	satisfied after variation. We show that on the drug
	bioavailability and Pagie-1 benchmark problems ULTRA
	produces significant improvements both in
	problem-solving power and in program size relative to
	standard operators. Experiments with factorial
	regression and with the Boolean 6-multiplexer problem
	demonstrate that ULTRA can manipulate programs that
	make use of hierarchical structure, but also that it is
	not always beneficial. The demonstrations evolve
	programs in the Push programming language, which makes
	repair particularly simple, but versions of the
	technique should be applicable in other genetic
	programming systems as well.",
	notes =	"http://cscs.umich.edu/gptp-workshops/ Part of
	\cite{Riolo:2013:GPTP} published after the workshop in
	2013",
	doi-url =	"http://dx.doi.org/10.1007/978-1-4939-0375-7_8",
}

@InProceedings{Spector:2012:GECCOcompANEW,
	author =	"Lee Spector",
	title =	"Assessment of Problem Modality by Differential
	Performance of Lexicase Selection in Genetic
	Programming: {A} Preliminary Report",
	booktitle =	"1st workshop on Understanding Problems (GECCO-UP)",
	year = 	"2012",
	NOeditor =	"Kent McClymont and Ed Keedwell",
	isbn13 =	"978-1-4503-1178-6",
	keywords =	"genetic algorithms, genetic programming, modal
	problems, selection, lexicase selection, problem
	metrics, modality",
	pages =	"401--408",
	month =	"7-11 " # jul,
	organisation = "SIGEVO",
	address =	"Philadelphia, Pennsylvania, USA",
	NOURL =  	"http://hampshire.edu/lspector/pubs/wk09p4-spector.pdf",
	doi =  	"doi:10.1145/2330784.2330846",
	publisher =	"ACM",
	publisher_address = "New York, NY, USA",
	size = 	"8 pages",
	abstract =	"Many potential target problems for genetic programming
	are modal in the sense that qualitatively different
	modes of response are required for inputs from
	different regions of the problem's domain. This paper
	presents a new approach to solving modal problems with
	genetic programming, using a simple and novel parent
	selection method called lexicase selection. It then
	shows how the differential performance of genetic
	programming with and without lexicase selection can be
	used to provide a measure of problem modality, and it
	argues that defining such a measure in this way is not
	as methodologically problematic as it may initially
	appear. The modality measure is illustrated through the
	analysis of genetic programming runs on a simple modal
	symbolic regression problem. This is a preliminary
	report that is intended in part to stimulate discussion
	on the significance of modal problems, methods for
	solving them, and methods for measuring the modality of
	problems. Although the core concepts in this paper are
	presented in the context of genetic programming, they
	are also relevant to applications of other forms of
	evolutionary computation to modal problems.",
	notes =	"p403 'allowing the high-performing individual [on any
	test case] to contribute to the following generation,
	regardless of [its] performance on other cases.' p405
	'with population size 10000 the overall cost of
	producing offspring using lexicase selection can exceed
	that of using ordinary tournaments by between one and
	two orders of magnitude'. (why?) Section 5: integer
	symbolic regresions with one, two or three 'modes'.
	Clojure lexicase.clj
	https://gist.github.com/lspector/2320883 Also known as
	\cite{2330846} Distributed at GECCO-2012. ACM Order
	Number 910122.",
	doi-url =	"http://dx.doi.org/10.1145/2330784.2330846",
}

@InProceedings{McKay:2000:GECCO,
	author =	"McKay, Robert I.",
	title =	"Fitness Sharing in Genetic Programming",
	pages =	"435--442",
	year = 	"2000",
	publisher =	"Morgan Kaufmann",
	booktitle =	"Proceedings of the Genetic and Evolutionary
	Computation Conference (GECCO-2000)",
	NOeditor =	"Darrell Whitley and David Goldberg and Erick Cantu-Paz
	and Lee Spector and Ian Parmee and Hans-Georg Beyer",
	address =	"Las Vegas, Nevada, USA",
	publisher_address = "San Francisco, CA 94104, USA",
	month =	"10-12 " # jul,
	keywords =	"genetic algorithms, genetic programming",
	ISBN = 	"1-55860-708-0",
	URL =  	"http://www.cs.bham.ac.uk/~wbl/biblio/gecco2000/GP256.pdf",
	URL =  	"http://www.cs.bham.ac.uk/~wbl/biblio/gecco2000/GP256.ps",
	notes =	"A joint meeting of the ninth International Conference
	on Genetic Algorithms (ICGA-2000) and the fifth Annual
	Genetic Programming Conference (GP-2000) Part of
	\cite{whitley:2000:GECCO}",
}


@Article{spector:2002:GPEM,
	author =       "Lee Spector and Alan Robinson",
	title =        "Genetic Programming and Autoconstructive Evolution
	with the Push Programming Language",
	journal =      "Genetic Programming and Evolvable Machines",
	year =         "2002",
	volume =       "3",
	number =       "1",
	pages =        "7--40",
	month =        mar,
	keywords =     "genetic algorithms, genetic programming, artificial
	life, modularity, programming languages,
	self-adaptation",
	ISSN =         "1389-2576",
	URL =          "http://hampshire.edu/lspector/pubs/push-gpem-final.pdf",
	doi =          "doi:10.1023/A:1014538503543",
	abstract =     "Push is a programming language designed for the
	expression of evolving programs within an evolutionary
	computation system. This article describes Push and
	illustrates some of the opportunities that it presents
	for evolutionary computation. Two evolutionary
	computation systems, PushGP and Pushpop, are described
	in detail. PushGP is a genetic programming system that
	evolves Push programs to solve computational problems.
	Pushpop, an ?autoconstructive evolution? system, also
	evolves Push programs but does so while simultaneously
	evolving its own evolutionary mechanisms.",
	notes =        "Article ID: 395988",
}

@InProceedings{1068292,
	author =       "Lee Spector and Jon Klein and Maarten Keijzer",
	title =        "The {Push3} execution stack and the evolution of
	control",
	booktitle =    "{GECCO 2005}: Proceedings of the 2005 conference on
	Genetic and evolutionary computation",
	year =         "2005",
	ISBN =         "1-59593-010-8",
	pages =        "1689--1696",
	address =      "Washington DC, USA",
	URL =          "http://www.cs.bham.ac.uk/~wbl/biblio/gecco2005/docs/p1689.pdf",
	doi =          "doi:10.1145/1068009.1068292",
	publisher =    "ACM Press",
	publisher_address = "New York, NY, 10286-1405, USA",
	organisation = "ACM SIGEVO (formerly ISGEC)",
	keywords =     "genetic algorithms, genetic programming, combinators,
	experimentation, exponentiation, factorial, Fibonacci
	sequence, iteration, languages, parity, push,
	recursion, reversing a list, sorting, stack-based
	genetic programming",
	abstract =     "One of Push's attractive features in this context is
	its transparent support for the expression and
	evolution of modular architectures and complex control
	structures, achieved through explicit code
	self-manipulation. The latest version of Push, Push3,
	enhances this feature by permitting explicit
	manipulation of an execution stack that contains the
	expressions that are queued for execution in the
	interpreter. presents a series of examples in which
	Push3 was used with a simple genetic programming system
	(PushGP) to evolve programs with non-trivial control
	structures.",
	notes =        "GECCO-2005 A joint meeting of the fourteenth
	international conference on genetic algorithms
	(ICGA-2005) and the tenth annual genetic programming
	conference (GP-2005).
	
	ACM Order Number 910052
	
	Cited by \cite{eurogp06:AgapitosLucas}
	
	EXEC stack. Combinators. Reentrant p1691 'the
	re-entrant interpreter allows for the controlled
	execution of a particular number of instructions per
	time-step.' Reversing a list. Factorial. Fibonacci.
	Parity. Powers of two, integer exponentiation
	Expt(2,n). Sorting a list.",
}

%% Simplification in Push

@MastersThesis{Robinson:2001:GPtieus,
  author =	"Alan Robinson",
  title =	"Genetic Programming: Theory, Implementation, and the
		 Evolution of Unconstrained Solutions",
  school =	"Hampshire College",
  year = 	"2001",
  type = 	"Division III thesis",
  month =	may,
  keywords =	"genetic algorithms, genetic programming, PushGP, LJGP
		 Linear Java GP, Lawnmower problem, Grazer problem",
  URL =  	"http://hampshire.edu/lspector/robinson-div3.pdf",
  URL =  	"http://citeseer.ist.psu.edu/498673.html",
  size = 	"127 pages",
  abstract =	"Part I: Background 1 INTRODUCTION 1.1 BACKGROUND ?
		 AUTOMATIC PROGRAMMING 1.2 THIS PROJECT 1.3 SUMMARY OF
		 CHAPTERS 2 GENETIC PROGRAMMING REVIEW Part II: PushGP 3
		 THE PUSH LANGUAGE & PUSHGP 4 PUSHGP COMPARED TO GP2
		 WITH ADFS 4.1 CAN A MORE FLEXIBLE SYSTEM PERFORM AS
		 WELL? 4.2 THE COMPUTATIONAL EFFORT METRIC 4.3 MEASURING
		 MODULARITY 4.4 SOLVING SYMBOLIC REGRESSION 4.5 EVEN
		 PARITY AS A GP BENCHMARK 4.6 SOLVING EVEN-FOUR-PARITY
		 USING PUSHGP AND STACK INPUT 4.7 EVEN-FOUR-PARITY WITH
		 INPUT FUNCTIONS 4.8 EVEN-SIX-PARITY 4.9 SOLVING
		 EVEN-N-PARITY 4.10 CONCLUSIONS DRAWN FROM THIS CHAPTER
		 5 VARIATIONS IN GENETIC OPERATORS 5.1 PERFORMANCE OF
		 BASE PUSHGP OPERATORS 5.2 VARIATIONS IN CROSSOVER 5.3
		 VARIATIONS IN MUTATION 5.4 EMPIRICAL TESTS WITH NEW
		 OPERATORS 5.5 CONCLUSIONS DRAWN FROM THESE RUNS 6
		 NEWGROUND ? EVOLVING FACTORIAL Part III: LJGP 7 LINEAR
		 CODED GENETIC PROGRAMMING IN JAVA 7.4 DISTRIBUTED
		 PROCESSING 8 LJGP USER?S GUIDE 8.1 ENCODING A PROBLEM
		 8.2 LJGP PACKAGES AND CLASSES OVERVIEW 8.3 VCPU
		 PROGRAMS 9 LJGP APPLIED 9.1 LAWNMOWER PILOT STUDY 9.2
		 PROBLEM DESCRIPTION 9.3 THE GENETIC MAKEUP OF AN
		 INDIVIDUAL 9.4 THE MECHANICS OF EVOLUTION 9.5 PILOT
		 RUNS OF THE LAWNMOWER PROBLEM 9.6 GRAZER PILOT STUDY
		 9.7 CONCLUSION TO LJGP APPLIED Conclusion APPENDIX A.
		 COMPUTATIONAL EFFORT ? LISP CODE APPENDIX B. GENETIC
		 PROGRAMMING SYSTEMS IN JAVA APPENDIX C. LJGP/JAVA-VM
		 BENCHMARKS",
}

@InProceedings{Spector:2014:GECCOcomp,
  author =	"Lee Spector and Thomas Helmuth",
  title =	"Effective simplification of evolved push programs
		 using a simple, stochastic hill-climber",
  booktitle =	"GECCO Comp '14: Proceedings of the 2014 conference
		 companion on Genetic and evolutionary computation
		 companion",
  year = 	"2014",
  NOeditor =	"Christian Igel and Dirk V. Arnold and Christian Gagne
		 and Elena Popovici and Anne Auger and Jaume Bacardit
		 and Dimo Brockhoff and Stefano Cagnoni and Kalyanmoy
		 Deb and Benjamin Doerr and James Foster and Tobias
		 Glasmachers and Emma Hart and Malcolm I. Heywood and
		 Hitoshi Iba and Christian Jacob and Thomas Jansen and
		 Yaochu Jin and Marouane Kessentini and Joshua D.
		 Knowles and William B. Langdon and Pedro Larranaga and
		 Sean Luke and Gabriel Luque and John A. W. McCall and
		 Marco A. {Montes de Oca} and Alison Motsinger-Reif and
		 Yew Soon Ong and Michael Palmer and Konstantinos E.
		 Parsopoulos and Guenther Raidl and Sebastian Risi and
		 Guenther Ruhe and Tom Schaul and Thomas Schmickl and
		 Bernhard Sendhoff and Kenneth O. Stanley and Thomas
		 Stuetzle and Dirk Thierens and Julian Togelius and
		 Carsten Witt and Christine Zarges",
  isbn13 =	"978-1-4503-2881-4",
  keywords =	"genetic algorithms, genetic programming: Poster",
  pages =	"147--148",
  month =	"12-16 " # jul,
  organisation = "SIGEVO",
  address =	"Vancouver, BC, Canada",
  URL =  	"http://doi.acm.org/10.1145/2598394.2598414",
  doi =  	"doi:10.1145/2598394.2598414",
  publisher =	"ACM",
  publisher_address = "New York, NY, USA",
  abstract =	"Genetic programming systems often produce programs
		 that include unnecessary code. This is undesirable for
		 several reasons, including the burdens that
		 overly-large programs put on end-users for program
		 interpretation and maintenance. The problem is
		 exacerbated by recently developed techniques, such as
		 genetic programming with geometric semantic crossover,
		 that tend to produce enormous programs. Methods for
		 automatically simplifying evolved programs are
		 therefore of interest, but automatic simplification is
		 non-trivial in the context of traditional program
		 representations with unconstrained function sets. Here
		 we show how evolved programs expressed in the
		 stack-based Push programming language can be
		 automatically and reliably simplified using a simple,
		 stochastic hill-climber. We demonstrate and
		 quantitatively characterise this simplification process
		 on programs evolved to solve four non-trivial genetic
		 programming problems with qualitatively different
		 function sets.",
  notes =	"Also known as \cite{2598414} Distributed at
		 GECCO-2014.",
  doi-url =	"http://dx.doi.org/10.1145/2598394.2598414",
}

@InProceedings{Zhan:2014:GECCOcomp,
  author =	"Haoxi Zhan",
  title =	"A quantitative analysis of the simplification genetic
		 operator",
  booktitle =	"GECCO 2014 student workshop",
  year = 	"2014",
  editor =	"Tea Tusar and Boris Naujoks",
  isbn13 =	"978-1-4503-2881-4",
  keywords =	"genetic algorithms, genetic programming",
  pages =	"1077--1080",
  month =	"12-16 " # jul,
  organisation = "SIGEVO",
  address =	"Vancouver, BC, Canada",
  URL =  	"http://doi.acm.org/10.1145/2598394.2605684",
  doi =  	"doi:10.1145/2598394.2605684",
  publisher =	"ACM",
  publisher_address = "New York, NY, USA",
  abstract =	"The simplification function was introduced to PushGP
		 as a tool to reduce the sizes of evolved programs in
		 final reports. While previous work suggests that
		 simplification could reduce the sizes significantly,
		 nothing has been done to study its impacts on the
		 evolution of Push programs. In this paper, we show the
		 impact of simplification as a genetic operator. By
		 conducting test runs on the U.S. change problem, we
		 show that using simplification operator with PushGP,
		 lexicase selection and ULTRA could increase the
		 possibility to find solutions in the short term while
		 it might remove some useful genetic materials for the
		 long term.",
  notes =	"Clojush Also known as \cite{2605684} Distributed at
		 GECCO-2014.",
  doi-url =	"http://dx.doi.org/10.1145/2598394.2605684",
}



%% Simplification in GP

@InProceedings{Kinzett:2010:cec,
  author =	"David Kinzett and Mengjie Zhang and Mark Johnston",
  title =	"Investigation of simplification threshold and noise
		 level of input data in numerical simplification of
		 genetic programs",
  booktitle =	"IEEE Congress on Evolutionary Computation (CEC 2010)",
  year = 	"2010",
  address =	"Barcelona, Spain",
  month =	"18-23 " # jul,
  publisher =	"IEEE Press",
  keywords =	"genetic algorithms, genetic programming",
  isbn13 =	"978-1-4244-6910-9",
  abstract =	"In tree based Genetic Programming (GP) there is a
		 tendency for program sizes to increase as the run
		 proceeds without a corresponding improvement in
		 fitness. This increases resource usage, both memory and
		 CPU time, and may result in over-fitting the training
		 data. Numerical simplification is a method for removing
		 redundant code from the program trees as the run
		 proceeds. Compared with the canonical genetic
		 programming method, numerical simplification can
		 generate much smaller programs, use much shorter
		 evolutionary training times and achieve comparable
		 effectiveness performance. A key parameter of this
		 method is the simplification threshold. This paper
		 examines whether there exists any relationship between
		 the noise level in the input data and the optimum value
		 for the simplification threshold and, if it exists,
		 what that relationship is. Our results suggest that
		 there is a relationship between the optimum value of
		 the simplification threshold and the level of noise in
		 the input data and that a lower bound for the optimum
		 simplification threshold is equal to the noise level
		 and an upper bound is five times the noise level.",
  doi =  	"doi:10.1109/CEC.2010.5586181",
  notes =	"WCCI 2010. Also known as \cite{5586181}",
  doi-url =	"http://dx.doi.org/10.1109/CEC.2010.5586181",
}